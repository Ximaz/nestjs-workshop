# Workshop - API REST in NestJS

✔️ Learn the basics of REST API.

✔️ Discover the [NestJS](https://github.com/nestjs/nest) framework.

✔️ Read and write files in TypeScript.

> 💡 [What is a REST API ?](https://blog.postman.com/rest-api-examples/)

## Step 0 : Initialization

Follow [this guidelines](./SETUP.md) to get ready to work with NestJS.

## Step 1 : Hello World !

At the root of this repository, you will find a directory called `rest-api`.

This folder contains all the default source code generated by NestJS in order
to create a Hello World application.

In this folder, you will find :

- `src` : This folder contains the whole application source code;
- `test` : This folder contains all the tests that you may write along the way;
- `tsconfig(.build).json` : The required JSON files to transpile TypeScript;
- `.eslintrc.js`, `.prettierc` : Some files for TypeScript formatting;
- `nest-cli.json` : A NestJS configuration file;
- `package.json`, `pnpm-lock.yaml` : The pnpm packages metadata;
- `README.md` : The NestJS generated README.md;
- `database.json` : A local fake JSON database for the steps below;

We will focus on the `src` folder as it will contain the source code you will
write. Note you may encounter other file structure to build a REST API.

Inside the `src` folder, you will find :
- `app.controller.spec.ts` : A file dedicated to write Controller tests;
- `app.module.ts` : The App **`Module`** implementation;
- `app.controller.ts` : The App **`Controller`** implementation;
- `app.service.ts` : The App **`Service`** implementation;
- `main.ts` : The HTTP server entrypoint;
- `db/` : A folder containing NestJS source code for a fake database adapter;

You may also notice a folder called `auth`, but we will get to that one later.

There is also a folder called `items`. It will contain your source code.

What are `Module`s, `Controller`s and `Service`s ?

### `Module`

A `Module` is a class which exposes other classes, mostly `Controller`s and
`Service`s.

See it as a way to export things in a way that allows us to write unit tests
the most efficient way.

### `Controller`

A `Controller` is a class which methods are responsible for recieving HTTP
requests.

When you go on a web browser and you type any URL, for instance :
`https://my-super-website.com/hello-world`
We may imagine a `hello-world.controller.ts` which is responsible for dealing
with your web browser request.

It is in charge to respond with an appropriate HTTP response. To know what it
has to send back to the client, it will transfer the request to a `Service`.

Note that a `Controller` may host many endpoints to dela with the same kind of
*objects*. For instance, an `Item` object may be processed by a `Controller`
which has the following routes :
- `GET /items/` : Returns a list of items;
- `GET /items/:itemId` : Returns detailed data about an item based on it's ID;
- `POST /items/` : Creates a new item;
- `PUT /items/:itemId` : Updates an item based on it's ID;
- `DELETE /items/:itemId` : Deletes an item based on it's ID;

The above endpoints are the least requirements to make a [`CRUD`](https://fr.wikipedia.org/wiki/CRUD).

### `Service`

A `Service` is where all the business logic happens. You have some API request
to do ? Some database calls to execute ? That's the place.

### Example

The `Module` implemented in `app.module.ts` exposes the `app.controller.ts`
`Controller` and it's related `Service` called `app.service.ts`.

Once a request arrives, the HTTP server implemented in `main.ts` will capture
the request via the `app.controller.ts` `Controller`. It will check that the
[HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
is accepted and it matches an existing endpoint. If so, it transfers the
request content to the `app.service.ts`. The `Service` will generate a proper
HTTP response which will be send back to the client through the `Controller`
defined in `app.controller.ts`.

## Step 2 : Your first routes

Now that you are familiar with the creation of a `Controller`, you will learn
to use different, but proper, HTTP methods.

(If you did not understand what the `app.controller.ts` does, or how it does it,
feel free to ask.)

Here, we will [send some data](https://rapidapi.com/guides/send-data-to-server)
to a `Controller` endpoint so that we can perform actions.

Let's create two endpoints :

The first endpoint will return a JSON object representing the template used to
create a new item object :
- Method : `GET`;
- Endpoint : `/items/template`;
- Response :
```json
{
  "name": "name",
  "description": "description",
  "price": 0
}
```

The second endpoint will accept a body representing the item object and will
simply return that same object. No data processing yet :
- Method : `POST`;
- Endpoint : `/items/display`;
- Body : `<JSON item object>`;
- Response : `<the sent body>`;

You may start your HTTP server using the following command :
```bash
cd rest-api
pnpm start:dev # Starts a new development server with --watch.
```

Then you can test your endpoints using cURL in a command line :
```bash
# Test the first endpoint :
curl http://localhost:3000/items/template

# Output :
# {"name":"name","description":"description","price":0}

# Test the second endpoint
curl http://localhost:3000/items/display \
    -H "Content-Type: application/json" \
    --data '{"name":"my item","description":"my super item","price":10}'

# Output :
# {"name":"my item","description":"my super item","price":10}
```

Quick tips :

> An item is a data **`Model`**, you can see it's type in `src/db/models/item.d.ts`.

> [NestJS Controller documentation](https://docs.nestjs.com/controllers).

## Step 3 : Authorization middleware and custom errors

Having multiple endpoints is great, but sometimes we need a way to restrict
access to logged in users for example. That is where middlewares shine !

A middleware is a function that will be executed before the controller endpoint
processes the HTTP request. For instance, it can block unauthorized requests
before they get processed.

Do you remember that `src/auth` folder ? Feel free to take a look at it. It
contains two subfolders :
- `guards` : A guard is an abstraction that will proxy your request to a `strategy`;
- `strategies` : A strategy is where the auth middleware business logic operates;

You have to edit the file `src/auth/strategies/auth.strategy.ts` file so that
it only accept HTTP requests which `Authorization`'s header is not empty. If it
is empty, however, it will reject the request, returning a `403 - Unauthorized`
HTTP status code.

Once you fixed the strategy, you can use it inside your `Controller`. Above
the endpoint you want to protect (e.g. `/items/display`), add the following :
```ts
import { AuthGuard } from '../auth/guards/auth.guard';

/* ... */

@UseGuard(AuthGuard) // The middleware is used here
@Get("/display")
display(...) { ... }

/* ... */
```

> We won't use an actual authorization method here such as [JWT](https://jwt.io/)
> as it's out of scope for a discovery.

You can test that everything works fine with the following command :
```bash
# Test the itemDisplay endpoint (No authorization provided)
curl http://localhost:3000/items/display \
    -H "Content-Type: application/json" \
    --data '{"name":"my item","description":"my super item","price":10}'

# Output :
# {"message":"Unauthorized","statusCode":401}

# Test the itemDisplay endpoint (Authorization provided)
curl http://localhost:3000/items/display \
    -H "Content-Type: application/json" \
    -H "Authorization: Hey \! I am allowed \!" \
    --data '{"name":"my item","description":"my super item","price":10}'

# Output :
# {"name":"my item","description":"my super item","price":10}
```

## Step 4 : Database interactions

As you may have see in the first step, there is a `db` folder inside the `src`
folder. It contains an "adapter" used to parse a JSON database file and operate
on it to read and write data.

In this step, you will have to write a CRUD with 5 endpoints : `create`, `list`,
`read`, `update` and `delete`. The database adapter already has methods with
the same names to perform the database actions. Focus on business logic, route
protection and correct HTTP methods.
